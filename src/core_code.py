# -*- coding: utf-8 -*-
"""Core_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_y2jKtdHzUCf3tvhuExlcpuZiUwoZIvE

#Core Code Q1
"""

#Table of Contents : Tree Structure Implementation

class Node:
    """A node representing a chapter, section, or subsection."""
    def __init__(self, title: str, parent=None):
        self.title = title
        self.children = []
        self.parent = parent

    def add_child(self, child_node):
        """Attach a new child to the current node."""
        self.children.append(child_node)
        child_node.parent = self


class Book:
    """Book class that manages the hierarchical TOC tree."""
    def __init__(self, title: str):
        self.root = Node(title)

    #Insert Method
    def insert(self, path, title):
        """
        Insert a title at the specified path.
        Example: [3, 2, 5] -> Chapter 3 → Subchapter 2 → Sub-subchapter 5
        """
        current = self.root

        # Traverse or create intermediate nodes as needed
        for level, index in enumerate(path):
            if index <= 0:
                raise ValueError("Path indices must be positive integers (1-based).")

            # Create placeholder nodes if path exceeds current children count
            while len(current.children) < index:
                placeholder_title = f"Untitled {len(current.children) + 1}"
                current.add_child(Node(placeholder_title))

            current = current.children[index - 1]

        # Assign the title to the final node
        current.title = title

    # ------------------------------------------------------------------
    # PRINT TOC METHOD
    # ------------------------------------------------------------------
    def print_toc(self, mode="plain"):
        """Display the TOC in plain, indented, or numbered mode."""
        if mode not in ["plain", "indented", "numbered"]:
            raise ValueError("Mode must be one of: 'plain', 'indented', 'numbered'")

        def pre_order_dfs(node, level=0, numbering=[]):
            # Skip printing root title for plain hierarchy (optional)
            if node != self.root:
                if mode == "plain":
                    print(node.title)
                elif mode == "indented":
                    print("  " * level + node.title)
                elif mode == "numbered":
                    num_str = ".".join(map(str, numbering))
                    print(f"{node.title}")

            for idx, child in enumerate(node.children, start=1):
                pre_order_dfs(child, level + 1, numbering + [idx])

        pre_order_dfs(self.root)

    # ------------------------------------------------------------------
    # DEPTH METHOD
    # ------------------------------------------------------------------
    def depth(self, node_title):
        """Return the depth of the first node matching the title."""
        def pre_order_dfs(node, level):
            if node.title == node_title:
                return level
            for child in node.children:
                d = pre_order_dfs(child, level + 1)
                if d != -1:
                    return d
            return -1

        return pre_order_dfs(self.root, 0)

    # ------------------------------------------------------------------
    # HEIGHT METHOD
    # ------------------------------------------------------------------
    def height(self):
        """Return the height of the tree (max depth from root)."""
        def pre_order_dfs_height(node):
            if not node.children:
                return 0
            return 1 + max(pre_order_dfs_height(child) for child in node.children)
        return pre_order_dfs_height(self.root)

"""#Core Code Q2

No class was necessary for this question, so all functions are included in testing file and final report.
"""